# -*- coding: utf-8 -*-
"""Assignment_3_MA348.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mob-MZPht8NR462tkk6ovrZfPGpNO5Mo

Problem 4.1 

The "divide and arrange" method, an old-time method for approximating the square root of any positive number $a$ can be formulated as 

$x_{i+1} = \frac{x_i+a/x_i}{2}$

Write a well and structured Python function to implement this iterative method based on the algorithm outlined in figure 4.2.
"""

#import packages
import math 
import numpy as np

#define a function for the divide and arrange method
def divArrange(a, x):
  x = (x+(a/x))/2
  return x

def SolutionFunc(a, guess, es = 1e-4, maxit = 50):
  for i in range(maxit):
    Solution = divArrange(a, guess)
    #approximate relative error
    ea = np.abs((Solution - guess)/Solution)*100
    if ea < es:
      break
    guess = Solution
  return i, Solution, ea

#Testing with a = 2 and initial guess of 1.5
a = 2
guess = 1.5
(i, final, ea) = SolutionFunc(a, guess)
print(F"The square root of {a} with an initial guess of {guess} is {final}, found at iteration {i} with a predicted relative error of {ea}")

#testing with a = 4 and initial guess of 20
a = 4
guess = 20
(i, final, ea) = SolutionFunc(a, guess)
print(F"The square root of {a} with an initial guess of {guess} is {final}, found at iteration {i} with a predicted relative error of {ea}")

#Allow user input to solve function with any positive integer
while True:
    a = int(input('Input a positive integer for a: '))
    if a < 1:
        print('\nThis is not a positive integer. Please try another number.')
        print()
    else: 
        break
while True:
    guess = int(input('\nInput a positive integer for your initial guess: '))
    if guess < 1:
        print('\nThis is not a positive integer. Please try another number.')
        print()
    else: 
        break

#print solution

(i, final, ea) = SolutionFunc(a, guess)
print(F"\nThe square root of {a} with an initial guess of {guess} is {final}, found at iteration {i} with a predicted relative error of {ea}")

"""Problem 4.4

For computers, the machine epsilon, $\epsilon$, can also be thought of as the smallest number that when added to one gives a number greater than one. An algorithm based on this idea can be developed as

Step 1. Set $\epsilon = 1$.

Step 2. If $1 + \epsilon$ is less than or equal to 1, go to Step 5; otherwise continue to Step 3.

Step 3.$\epsilon = \frac{\epsilon}{2}$

Step 4. Return to Step 2. 

Step 5. $\epsilon = 2\epsilon$

Write your own Python script based on this algorithm to determine the machine epsilon. Validate the result by comparing it with the value returned from the Python NumPy command, 

```
np.finfo(float).eps
```

If the values are different, consider why that might be.


"""

#create function for determining machine epsilon
def machEps():
  #step 1
  eps = 1
  #step 3-4
  while True:
    if (eps+1) <= 1:
      break
    eps = eps/2
  #step 5
  epsAns = 2 * eps
  return epsAns

#Test function ability and result
machEps()

#Test NumPy result
np.finfo(float).eps

"""Notes on Problem 4.4

The values for the function I created matches the values found using the NumPy command.

Problem 4.10

The Maclaurin series expansion for $cos(x)$ is 

$cos(x) = 1-\frac{x^2}{2} + \frac{x^4}{4!} - \frac{x^6}{6!} + \frac{x^8}{8!} - \cdots $

Starting with the simplest version, $cos(x) \cong 1$, add terms one at a time to estimate $cos(\frac{\pi}{3})$. After each new term is added, compute the true and approximate percent relative errors. Use your calculator or Python to determine the true value. Add terms until the absolute value of the approximate error estimate falls below an error criterion correspoinding to three significant figures.
"""

#Problem 4.10
import math
from math import pi
from math import cos
from math import factorial

#Solve cos pi/3 in simple terms 
Solution = cos(pi / 3)
print(Solution)

#Maclaurin Series
#Define cos pi/3 
x = pi/3
x = float(x)
Solution = cos(x)

#begin with cos (pi/3) = 1
a = abs(1-Solution)
print('Error in 1st iteration of the Maclaurin series: ', a)

#cos(pi/3) = 1-x^2/2!
two = 1 - x**2/2
b = abs(two - Solution)
print('Error in 2nd iteration of the Maclaurin series: ', b)

#cos(pi/3) = 1-(x^2/2!)+(x^4/4!)
four = two + (x**4)/factorial(4)
c = abs(four - Solution)
print('Error in 3rd iteration of the Maclaurin series: ',c)

#cos(pi/3) = 1-(x^2/2!)+(x^4/4!)-(x^6/6!)
six = four - (x**6)/factorial(6)
d = abs(six - Solution)
print('Error in 4th iteration of the Maclaurin series: ',d)

#cos(pi/3) = 1-(x^2/2!)+(x^4/4!)-(x^6/6!)+(x^8/8!)
eight = six + (x**8)/factorial(8)
e = abs(eight - Solution)
print('Error in 5th iteration of the Maclaurin series: ',e)

#percent error at 4th iteration
perError = abs((six - Solution)/Solution)*100
print('The percent error at the 4th iteration of the Maclaurin series is: ', perError)

"""Solution for Problem 4.10

It appears that the error criterion is met at the 4th iteration of the Maclaurin series, where x is raised to the power of 6 and divide by 6!: 

$cos(x)=1-\frac{x^2}{2}+\frac{x^4}{4!}-\frac{x^6}{6!}$

The error from the true value of $cos(\frac{\pi}{3})$ at this point in the series is: 

Error in Maclaurin series:  3.543467108740872e-05

The percent error at the 4th iteration is: 0.007086934217481742

Problem 4.23

One common instance where subtractive cancellation occurs involves finding the roots of a parabola, $ax^2+bx+c$, with the quadratic formula 

$x = \frac{-b \pm \sqrt{b^2-4ac}}{2a}$

For cases where $b^2 \gg 4ac$, the difference in the numerator can be very small and roundoff errors can occur. In such cases, an alternative formulation can be used to minimize subtractive cancellation:

$x = \frac{-2c}{b\pm \sqrt{b^2-4ac}}$

Use 5-digit arithmetic with chopping to determine the roots of the following equation with both versions of the quadratic formula.

$x^2-5000.002x+10$
"""

#import packages
import math
from math import sqrt

#define the parts of the given equation
a = float(1)
b = float(5000.002)
c = float(10)

#Quadratic formula
xq1 = (-b + sqrt((b**2)-(4*a*c)))/(2*a)
xq2 = (-b - sqrt((b**2)-(4*a*c)))/(2*a)
#print result
print(F'The roots of the equation utilizing the common form of the Quadratic Formula are: {"%.5f" % xq1} and {xq2}')

#Alternative formula
xa1 = (-2*c)/(b + sqrt((b**2) - 4*a*c))
xa2 = (-2*c)/(b - sqrt((b**2) - 4*a*c))
#print result
print(F'The roots of the equation utilizing the alternative formulation are: {"%.5f" % xa1} and {"%.1f" % xa2}')

"""Solution to Problem 4.23

The solutions to both equations, using the 5 digit arithmetic and chopping end up being the same solution. Without chopping, the solutions are slightly different, I will create a code to calculate those errors between solutions below. 
"""

#Quadratic formula
xq1 = (-b + sqrt((b**2)-(4*a*c)))/(2*a)
xq2 = (-b - sqrt((b**2)-(4*a*c)))/(2*a)

#Alternative formula
xa1 = (-2*c)/(b + sqrt((b**2) - 4*a*c))
xa2 = (-2*c)/(b - sqrt((b**2) - 4*a*c))

#Calculate the error
error1 = abs(xq1 - xa1)
error2 = abs(xq2 - xa2)

#print results
print(F'The error between the roots of the equation using the two types of quadratic formula are: {error1} and {error2}')